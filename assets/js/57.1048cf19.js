(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{545:function(e,t,s){"use strict";s.r(t);var a=s(44),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"重绘和回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘和回流"}},[e._v("#")]),e._v(" 重绘和回流")]),e._v(" "),s("blockquote",[s("ul",[s("li",[e._v("回流 —— 将DOM节点和CSS样式结合准确的计算出DOM节点的表现形式（位置、形状），计算的过程就是回流")]),e._v(" "),s("li",[e._v("重绘 —— 经过了回流计算之后，就了解到哪些DOM显示（如何显示）和不显示，将DOM显示到浏览器中的过程就是重绘")])])]),e._v(" "),s("p",[s("strong",[e._v("回流必将引起重绘，重绘不一定会引起回流。")])]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("浏览器使用流式布局模型 (Flow Based Layout)。")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("浏览器会把"),s("code",[e._v("HTML")]),e._v("解析成"),s("code",[e._v("DOM")]),e._v("，把"),s("code",[e._v("CSS")]),e._v("解析成"),s("code",[e._v("CSSOM")]),e._v("，"),s("code",[e._v("DOM")]),e._v("和"),s("code",[e._v("CSSOM")]),e._v("合并就产生了"),s("code",[e._v("Render Tree")]),e._v("。")])]),e._v(" "),s("li",[s("p",[e._v("有了"),s("code",[e._v("RenderTree")]),e._v("，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。")])]),e._v(" "),s("li",[s("p",[e._v("由于浏览器使用流式布局，对"),s("code",[e._v("Render Tree")]),e._v("的计算通常只需要遍历一次就可以完成，但"),s("code",[e._v("table")]),e._v("及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用"),s("code",[e._v("table")]),e._v("布局的原因之一。")])])])]),e._v(" "),s("h3",{attrs:{id:"a-回流-reflow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-回流-reflow"}},[e._v("#")]),e._v(" a. 回流（Reflow）")]),e._v(" "),s("p",[e._v("当"),s("code",[e._v("Render Tree")]),e._v("中部分或全部元素的尺寸、结构、或某些属性发生改变时，"),s("strong",[e._v("浏览器重新渲染部分或全部文档的过程")]),e._v("称为回流。")]),e._v(" "),s("p",[e._v("会导致回流的操作：")]),e._v(" "),s("ul",[s("li",[e._v("页面首次渲染")]),e._v(" "),s("li",[e._v("浏览器窗口大小发生改变")]),e._v(" "),s("li",[e._v("元素尺寸或位置发生改变")]),e._v(" "),s("li",[e._v("元素内容变化（文字数量或图片大小等等）")]),e._v(" "),s("li",[e._v("元素字体大小变化")]),e._v(" "),s("li",[e._v("添加或者删除"),s("strong",[e._v("可见")]),e._v("的"),s("code",[e._v("DOM")]),e._v("元素")]),e._v(" "),s("li",[e._v("激活"),s("code",[e._v("CSS")]),e._v("伪类（例如："),s("code",[e._v(":hover")]),e._v("）")]),e._v(" "),s("li",[e._v("查询某些属性或调用某些方法")])]),e._v(" "),s("p",[e._v("一些常用且会导致回流的属性和方法：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("clientWidth")]),e._v("、"),s("code",[e._v("clientHeight")]),e._v("、"),s("code",[e._v("clientTop")]),e._v("、"),s("code",[e._v("clientLeft")])]),e._v(" "),s("li",[s("code",[e._v("offsetWidth")]),e._v("、"),s("code",[e._v("offsetHeight")]),e._v("、"),s("code",[e._v("offsetTop")]),e._v("、"),s("code",[e._v("offsetLeft")])]),e._v(" "),s("li",[s("code",[e._v("scrollWidth")]),e._v("、"),s("code",[e._v("scrollHeight")]),e._v("、"),s("code",[e._v("scrollTop")]),e._v("、"),s("code",[e._v("scrollLeft")])]),e._v(" "),s("li",[s("code",[e._v("scrollIntoView()")]),e._v("、"),s("code",[e._v("scrollIntoViewIfNeeded()")])]),e._v(" "),s("li",[s("code",[e._v("getComputedStyle()")])]),e._v(" "),s("li",[s("code",[e._v("getBoundingClientRect()")])]),e._v(" "),s("li",[s("code",[e._v("scrollTo()")])])]),e._v(" "),s("h3",{attrs:{id:"b-重绘-repaint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-重绘-repaint"}},[e._v("#")]),e._v(" b. 重绘 (Repaint)")]),e._v(" "),s("p",[e._v("当页面中"),s("strong",[e._v("元素样式的改变并不影响它在文档流中的位置")]),e._v("时（例如："),s("code",[e._v("color")]),e._v("、"),s("code",[e._v("background-color")]),e._v("、"),s("code",[e._v("visibility")]),e._v("等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),e._v(" "),s("h2",{attrs:{id:"如何减少回流和重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何减少回流和重绘"}},[e._v("#")]),e._v(" 如何减少回流和重绘")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("尽量一次修改所有样式属性")]),e._v(" "),s("div",{staticClass:"language-diff extra-class"},[s("pre",{pre:!0,attrs:{class:"language-diff"}},[s("code",[s("span",{pre:!0,attrs:{class:"token unchanged"}},[s("span",{pre:!0,attrs:{class:"token prefix unchanged"}},[e._v(" ")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" const el = document.getElementById('app');\n")])]),s("span",{pre:!0,attrs:{class:"token deleted-sign deleted"}},[s("span",{pre:!0,attrs:{class:"token prefix deleted"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" el.style.padding = '5px';\n")]),s("span",{pre:!0,attrs:{class:"token prefix deleted"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" el.style.borderLeft = '1px';\n")])]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token inserted-sign inserted"}},[s("span",{pre:!0,attrs:{class:"token prefix inserted"}},[e._v("+")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" el.style.cssText += 'padding: 5px; border-left: 1px;'\n")])])])])])]),e._v(" "),s("li",[s("p",[e._v("批量修改DOM")]),e._v(" "),s("p",[e._v("即使元素脱离文档流，在脱离文档流的元素中修改完成，然后最后一次插入到DOM文档流中")]),e._v(" "),s("p",[e._v("有三种方式可以让DOM脱离文档流：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("隐藏元素，应用修改，重新显示")])]),e._v(" "),s("li",[s("p",[e._v("使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。")]),e._v(" "),s("div",{staticClass:"language-diff extra-class"},[s("pre",{pre:!0,attrs:{class:"language-diff"}},[s("code",[s("span",{pre:!0,attrs:{class:"token unchanged"}},[s("span",{pre:!0,attrs:{class:"token prefix unchanged"}},[e._v(" ")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(' var ul = document.getElementById("ul");\n')])]),s("span",{pre:!0,attrs:{class:"token inserted-sign inserted"}},[s("span",{pre:!0,attrs:{class:"token prefix inserted"}},[e._v("+")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" var fragment = document.createDocumentFragment();\n")])]),s("span",{pre:!0,attrs:{class:"token unchanged"}},[s("span",{pre:!0,attrs:{class:"token prefix unchanged"}},[e._v(" ")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" for (var i = 0; i < 20; i++) {\n")]),s("span",{pre:!0,attrs:{class:"token prefix unchanged"}},[e._v(" ")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v('   var li = document.createElement("li");\n')]),s("span",{pre:!0,attrs:{class:"token prefix unchanged"}},[e._v(" ")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v('   li.innerHTML = "index: " + i;\n')])]),s("span",{pre:!0,attrs:{class:"token deleted-sign deleted"}},[s("span",{pre:!0,attrs:{class:"token prefix deleted"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v("   ul.appendChild(li);\n")])]),s("span",{pre:!0,attrs:{class:"token inserted-sign inserted"}},[s("span",{pre:!0,attrs:{class:"token prefix inserted"}},[e._v("+")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v("   fragment.appendChild(li);\n")])]),s("span",{pre:!0,attrs:{class:"token unchanged"}},[s("span",{pre:!0,attrs:{class:"token prefix unchanged"}},[e._v(" ")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" }\n")])]),s("span",{pre:!0,attrs:{class:"token inserted-sign inserted"}},[s("span",{pre:!0,attrs:{class:"token prefix inserted"}},[e._v("+")]),s("span",{pre:!0,attrs:{class:"token line"}},[e._v(" ul.appendChild(fragment);\n")])])])])])]),e._v(" "),s("li",[s("p",[e._v("将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。")])])])]),e._v(" "),s("li",[s("p",[e._v("避免触发同步布局事件")])]),e._v(" "),s("li",[s("p",[e._v("对于复杂动画效果,使用绝对定位让其脱离文档流")])]),e._v(" "),s("li",[s("p",[e._v("css3硬件加速（GPU加速）")])])]),e._v(" "),s("h2",{attrs:{id:"参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[e._v("#")]),e._v(" 参考文献")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://www.zoo.team/article/browser-redraw",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器渲染之回流重绘"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);